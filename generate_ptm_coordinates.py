
import numpy as np
import pandas as pd
from ExonPTMapper import mapping
from ExonPTMapper import config as mapper_config

import datetime
import pyliftover
from tqdm import tqdm


def check_constitutive(ptm, nonconstitutive_list):
    """
    For a given list of ptms, check if any of the ptms are found in the list of nonconstitutive ptms, meaning that they have previously been found to be missing from isoforms in Ensembl

    Parameters
    ----------
    ptm : list
        List of PTMs to check (each ptm should be in the form of "UniProtID_ResiduePosition" (e.g. "P12345-1_Y100"))
    nonconstitutive_list : list
        List of PTMs that have been found to be nonconstitutive (based on data from ptm_info object generated by ExonPTMapper)
    """
    if ptm in nonconstitutive_list:
        return False    
    else:
        return True
        
def extract_ptm_position_of_primary_isoform(row):
    """
    For a given row in the ptm_coordinates dataframe, extract the position of the PTM in the primary isoform (canonical if available, else first isoform in list)
    """
    pass
        
def get_unique_ptm_info(ptm_coordinates):
    """
    For a given row in the ptm_coordinates dataframe, isolate PTM entries corresponding to the canonical isoform ID, if available. If not, use the first isoform ID in the list. Further, indicate whether the entry corresponds to a canonical or alternative isoform.

    Parameters
    ----------
    ptm_coordinates : pd.DataFrame
        DataFrame containing PTM coordinates, generated by ExonPTMapper package

    Returns
    -------
    pd.DataFrame
        DataFrame containing PTM coordinates with additional columns indicating the UniProtKB accession number, the isoform ID, the type of isoform (canonical or alternative), the residue of the PTM, the position of the PTM in the isoform, and any alternative entries that also contain the PTM

    """
    accession_list = []  #list of UniProtKB/Swiss-Prot accessions
    residue_list = []
    position_list = []
    isoform_list = []
    isoform_type = []
    for i,row in ptm_coordinates.iterrows():
        ptm_entries = row['Source of PTM'].split(';')
        residue = ptm_entries[0].split('_')[1][0]

        #iterate through each PTM entry and extract any that are associated with a canonical isoform. This will usually only be one, but in rare cases a PTM may be associated with multiple genes
        found_in_canonical = False
        positions = []
        accessions = []
        isoform_entries = []
        for ptm in ptm_entries:
            if ptm.split('_')[0] in mapper_config.canonical_isoIDs.values(): #check if the uniprot isoform ID is a canonical isoform. if so, add the position to the list of positions
                positions.append(ptm.split('_')[1][1:]) 
                accessions.append(ptm.split('-')[0]) #uniprot accession number
                isoform_entries.append(ptm.split('_')[0]) #uniprot isoform ID
                found_in_canonical = True #indicate that there is a PTM found in the canonical isoform

        
        #check if position in canonical was found. If so, join the positions into a single string. If not, use the position associated with the first listed isoform
        if found_in_canonical:
            positions = ';'.join(positions)
            accessions = ';'.join(accessions)
            isoform_entries = ';'.join(isoform_entries)
            isoform_type.append('Canonical')
        else:
            positions = ptm_entries[0].split('_')[1][1:]
            accessions = ptm_entries[0].split('-')[0]
            isoform_entries = ptm_entries[0].split('_')[0]
            isoform_type.append('Alternative')

        accession_list.append(accessions)
        residue_list.append(residue)
        position_list.append(positions)
        isoform_list.append(isoform_entries)

    ptm_coordinates['UniProtKB Accession'] = accession_list
    ptm_coordinates['Isoform ID'] = isoform_list
    ptm_coordinates['Isoform Type'] = isoform_type
    ptm_coordinates['Residue'] = residue_list
    ptm_coordinates['PTM Position in Isoform'] = position_list
    return ptm_coordinates

def convert_coordinates(ptm_coordinates, from_coord = 'hg38', to_coord = 'hg19'):
    """
    Given the ptm_coordinates dataframe, convert the genomic location of the PTMs from one coordinate system to another (e.g. hg38 to hg19, hg19 to hg38, etc.)

    Parameters
    ----------
    ptm_coordinates : pd.DataFrame
        DataFrame containing PTM coordinates
    from_coord : str
        Coordinate system to convert from (e.g. 'hg38', 'hg19', 'hg18')
    to_coord : str
        Coordinate system to convert to (e.g. 'hg38', 'hg19', 'hg18')
    """
    # convert coordinates to hg19 and hg38
    new_coords = []
    liftover_object = pyliftover.LiftOver(f'{from_coord}',f'{to_coord}')
    for i, row in tqdm(ptm_coordinates.iterrows(), total = ptm_coordinates.shape[0], desc = f'Converting from {from_coord} to {to_coord} coordinates'):
        new_coords.append(mapping.convert_genomic_coordinates(row[f'Gene Location ({from_coord})'], row['Chromosome/scaffold name'], row['Strand'], from_type = f'{from_coord}', to_type = f'{to_coord}', liftover_object = liftover_object))
    return new_coords





def generate_ptm_coordinates(remap_PTMs = False, phosphositeplus_filepath = None, output_dir = None, ptm_info = None):
    mapper = mapping.PTM_mapper()

    if remap_PTMs:
        mapper.find_ptms_all(phosphositeplus_file = phosphositeplus_filepath)
        mapper.mapPTMs_all()

    #get coordinate info
    if mapper.ptm_coordinates is None:
        raise ValueError('No PTM coordinates found. Please set remap_PTMs to True to generate PTM coordinates. If you want to include PhosphoSitePlus data, please also include location of phosphositeplus data file in phosphositeplus_filepath argument.')
    
    #copy ptm_coordinates file to be edited for easier use with PTM-POSE
    ptm_coordinates = mapper.ptm_coordinates.copy()

    #annotate with ptm position in canonical isoform
    #ptm_coordinates['UniProtKB Accession'] = ptm_coordinates['Source of PTM'].apply(lambda x: x.split(';'))
    #ptm_coordinates['Residue'] = ptm_coordinates['UniProtKB Accession'].apply(lambda x: x[0].split('_')[1][0])

    #get location of PTM in canonical isoform, if found in canonical isoform
    #ptm_coordinates['PTM Position in Isoform'] = ptm_coordinates['UniProtKB Accession'].apply(lambda x: [ptm.split('_')[1][1:] for ptm in x if ptm.split('_')[0] in config.canonical_isoIDs.values()])
    #ptm_coordinates['PTM Position in Isoform'] = ptm_coordinates['PTM Position in Isoform'].apply(lambda x: ';'.join(x) if len(x) > 0 else np.nan)
    #ptm_coordinates['Found in Canonical'] = ptm_coordinates['PTM Position in Isoform'].apply(lambda x: x == x)


    #set accession to use: if canonical use the non-isoform id, else use the first isoform id in list
    #ptm_coordinates['UniProtKB Accession'] = ptm_coordinates.apply(lambda x: ';'.join([ptm.split('-')[0]for ptm in x['UniProtKB Accession'] if ptm.split('_')[0] in config.canonical_isoIDs.values()]) if x['Found in Canonical'] else x['UniProtKB Accession'][0].split('_')[0], axis = 1) 
        #update location of PTM to be from first isoform in list if not found in canonical isoform
    #ptm_coordinates['PTM Position in Canonical Isoform'] = ptm_coordinates.apply(lambda x: x['PTM Position in Canonical Isoform'] if x['Found in Canonical'] else x['Source of PTM'].split(';')[0].split('_')[1][1:], axis = 1)
    ptm_coordinates = get_unique_ptm_info(ptm_coordinates)



    # convert coordinates to hg19 and hg38, then from hg19 to hg18
    ptm_coordinates['Gene Location (hg19)'] = convert_coordinates(ptm_coordinates, from_coord = 'hg38', to_coord = 'hg19')
    ptm_coordinates['Gene Location (hg18)'] = convert_coordinates(ptm_coordinates, from_coord = 'hg19', to_coord = 'hg18')

    #separate out PTMs that are found in UniProt accessions
    ptm_coordinates['PTM Position in Isoform'] = ptm_coordinates['PTM Position in Isoform'].str.split(';')
    ptm_coordinates['UniProtKB Accession'] = ptm_coordinates['UniProtKB Accession'].str.split(';')
    ptm_coordinates['Isoform ID'] = ptm_coordinates['Isoform ID'].str.split(';')
    ptm_coordinates = ptm_coordinates.explode(['UniProtKB Accession', 'Isoform ID', 'PTM Position in Isoform']).reset_index()


    #for further analysis
    ptm_coordinates['PTM'] = ptm_coordinates['Isoform ID'] + '_' + ptm_coordinates['Residue'] + ptm_coordinates['PTM Position in Isoform']

    if ptm_info is None:
        ptm_info = mapper.ptm_info.copy()
    #add whether or not the PTM is constitutive
    if 'PTM Conservation Score' not in ptm_info.columns:
        raise Warning('No PTM conservation score found in ptm_info object. Will not add column indicating whether the PTM is considered to be constitutive or not.')
    else:

        #grab nonconstitutive list from ptm_info object
        nonconstitutive_list = set(ptm_info[ptm_info['PTM Conservation Score'] != 1].index.values)

    
        const_list = []
        for i, row in tqdm(ptm_coordinates.iterrows(), total = ptm_coordinates.shape[0], desc = 'Checking for constitutive PTMs'):
            const_list.append(check_constitutive(row['PTM'], nonconstitutive_list))
        ptm_coordinates['Constitutive'] = const_list

        

   
    #add flanking sequence information    
    ptm_coordinates['Canonical Flanking Sequence'] = ptm_coordinates['PTM'].apply(lambda x: ptm_info.loc[x, 'Flanking Sequence'] if x == x else np.nan)

    #drop unnecessary columns and save
    #ptm_coordinates = ptm_coordinates.drop(columns = ['PTM Position in Canonical Isoform', 'PTM'], axis = 1)

    ptm_coordinates = ptm_coordinates[['Gene name', 'UniProtKB Accession', 'Isoform ID', 'Isoform Type', 'Residue', 'PTM Position in Isoform', 'Modification', 'Modification Class', 'Chromosome/scaffold name', 'Strand', 'Gene Location (hg38)', 'Gene Location (hg19)', 'Gene Location (hg18)', 'Constitutive', 'Canonical Flanking Sequence','MS_LIT', 'MS_CST', 'Source of PTM']]
    ptm_coordinates = ptm_coordinates.reset_index() #there will be some non-unique genomic coordinates, so reset index to ensure unique index values
    if output_dir is not None:
        ptm_coordinates.to_csv(output_dir + 'ptm_coordinates.csv', index = False)


        #write to text file indicating when the data was last updated
        with open(output_dir + 'last_updated.txt', 'w') as f:
            f.write(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    return ptm_coordinates